#!/usr/bin/env python3
import math
import pprint
import itertools
from typing import List, Tuple, Dict, Any, Optional
from functools import wraps

from loguru import logger
from beartype import beartype

import sympy
from sympy import (
    prime,
    simplify,
    init_printing,
    abc,
    symbols,
    shape,
    eye,
    pi,
    I,
    Expr,
    Integer,
    Number,
    FiniteSet,
)
from sympy.matrices import Matrix, ImmutableMatrix, BlockMatrix, ZeroMatrix, Identity
from sympy.functions import exp
from sympy.physics.quantum.dagger import Dagger
from sympy.printing.pretty.pretty import pprint as spprint


USE_UNICODE = True


def sprint(obj: Expr) -> None:
    spprint(obj, use_unicode=USE_UNICODE)


@beartype
def get_omega(p: int) -> Expr:
    return exp((2 * pi * I) / p)


@beartype
def get_primitive_pth_roots_of_unity(p: int) -> List[Expr]:
    omegas: List[Expr] = []
    for k in get_coprime_set(p):
        omegas.append(exp((2 * k * pi * I) / p))
    return omegas


# Stolen from: https://stackoverflow.com/a/40190938
@beartype
def get_coprime_set(modulo: int) -> List[int]:
    return [num for num in range(1, modulo) if math.gcd(num, modulo) == 1]


@beartype
def get_type_iii_gamma(
    a: int, b: int, p: int, q: Tuple[int, ...], omega: Expr
) -> List[ImmutableMatrix]:
    """
    Compute the elements of gamma, the matrix subgroup of U(a, b) generated by
    (p, q). See p. 395 in ``Spherical space forms, CR mappings, and proper maps
    between balls`` by D'Angelo and Lichtblau.
    """
    assert a + b == len(q)
    n = a + b

    # Generate rows.
    rows: List[List[int]] = []
    for j in range(n):
        row = [0 for _ in range(n)]
        row[j] = omega ** q[j]
        rows.append(row)

    s = ImmutableMatrix(Matrix(rows))
    assert s.is_square

    elements: List[Matrix] = []
    for j in range(p):
        gamma = s ** j
        elements.append(gamma)
    return elements


@beartype
def is_in_SU_AB(matrix: ImmutableMatrix, a: int, b: int) -> bool:
    assert matrix.is_square

    n = shape(matrix)[0]
    assert n == a + b

    I_ab = get_I_ab(a, b)
    A_dagger_I_ab_A = Dagger(matrix) * I_ab * matrix
    return A_dagger_I_ab_A == I_ab


@beartype
def get_I_ab(a: int, b: int) -> ImmutableMatrix:
    n = a + b
    assert n > 0
    if a == 0:
        return Identity(b).as_explicit()
    if b == 0:
        return Identity(a).as_explicit()
    I_ab = BlockMatrix(
        [[Identity(a), ZeroMatrix(a, b)], [ZeroMatrix(b, a), -Identity(b)]]
    )
    return I_ab.as_explicit()


def main() -> None:

    MAX_N = 8
    MAX_P = 9
    assert MAX_N <= MAX_P - 1

    for n in range(1, MAX_N):
        for a in range(n + 1):
            b = n - a
            for p in range(n + 1, MAX_P):
                assert n <= p - 1
                for q in itertools.combinations(range(1, p), n):
                    primitive_roots = get_primitive_pth_roots_of_unity(p)
                    logger.info(f"Checking n={n}, a={a}, b={b}, p={p}, q={q}")
                    for omega in primitive_roots:
                        group = get_type_iii_gamma(a, b, p, q, omega)
                        for gamma in group:
                            assert is_in_SU_AB(gamma, a, b)
                        logger.info(f"Gamma_{{{p};{q}}}:")
                        sprint(FiniteSet(*group))

                        # Only ever try one primitive root because they're all equivalent.
                        break


if __name__ == "__main__":
    main()
